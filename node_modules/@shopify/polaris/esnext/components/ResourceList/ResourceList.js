import React, { useCallback, useEffect, useReducer, useRef, useState, } from 'react';
import debounce from 'lodash/debounce';
import { EnableSelectionMinor } from '@shopify/polaris-icons';
import { classNames } from '../../utilities/css';
import { Button } from '../Button';
import { EventListener } from '../EventListener';
import { Sticky } from '../Sticky';
import { Spinner } from '../Spinner';
import { ResourceListContext, SELECT_ALL_ITEMS, } from '../../utilities/resource-list';
import { Select } from '../Select';
import { EmptySearchResult } from '../EmptySearchResult';
import { useI18n } from '../../utilities/i18n';
import { ResourceItem } from '../ResourceItem';
import { useLazyRef } from '../../utilities/use-lazy-ref';
import { BulkActions, CheckableButton, 
// eslint-disable-next-line import/no-deprecated
FilterControl, } from './components';
import styles from './ResourceList.scss';
const SMALL_SCREEN_WIDTH = 458;
const SMALL_SPINNER_HEIGHT = 28;
const LARGE_SPINNER_HEIGHT = 45;
function getAllItemsOnPage(items, idForItem) {
    return items.map((item, index) => {
        return idForItem(item, index);
    });
}
const isSmallScreen = () => {
    return typeof window === 'undefined'
        ? false
        : window.innerWidth < SMALL_SCREEN_WIDTH;
};
function defaultIdForItem(item, index) {
    return Object.prototype.hasOwnProperty.call(item, 'id')
        ? item.id
        : index.toString();
}
export const ResourceList = function ResourceList({ items, filterControl, emptyState, emptySearchState, resourceName: resourceNameProp, promotedBulkActions, bulkActions, selectedItems = [], selectable, hasMoreItems, loading, showHeader = false, totalItemsCount, sortValue, sortOptions, alternateTool, onSortChange, onSelectionChange, renderItem, idForItem = defaultIdForItem, resolveItemId, }) {
    const i18n = useI18n();
    const [selectMode, setSelectMode] = useState(Boolean(selectedItems && selectedItems.length > 0));
    const [loadingPosition, setLoadingPositionState] = useState(0);
    const [lastSelected, setLastSelected] = useState();
    const [smallScreen, setSmallScreen] = useState(isSmallScreen());
    const forceUpdate = useReducer((x = 0) => x + 1, 0)[1];
    const [checkableButtons, setCheckableButtons] = useState(new Map());
    const defaultResourceName = useLazyRef(() => ({
        singular: i18n.translate('Polaris.ResourceList.defaultItemSingular'),
        plural: i18n.translate('Polaris.ResourceList.defaultItemPlural'),
    }));
    const listRef = useRef(null);
    const handleSelectMode = (selectMode) => {
        setSelectMode(selectMode);
        if (!selectMode && onSelectionChange) {
            onSelectionChange([]);
        }
    };
    const handleResize = debounce(() => {
        const newSmallScreen = isSmallScreen();
        if (selectedItems &&
            selectedItems.length === 0 &&
            selectMode &&
            !newSmallScreen) {
            handleSelectMode(false);
        }
        if (smallScreen !== newSmallScreen) {
            setSmallScreen(newSmallScreen);
        }
    }, 50, { leading: true, trailing: true, maxWait: 50 });
    const isSelectable = Boolean((promotedBulkActions && promotedBulkActions.length > 0) ||
        (bulkActions && bulkActions.length > 0) ||
        selectable);
    const bulkSelectState = () => {
        let selectState = 'indeterminate';
        if (!selectedItems ||
            (Array.isArray(selectedItems) && selectedItems.length === 0)) {
            selectState = false;
        }
        else if (selectedItems === SELECT_ALL_ITEMS ||
            (Array.isArray(selectedItems) && selectedItems.length === items.length)) {
            selectState = true;
        }
        return selectState;
    };
    const resourceName = resourceNameProp
        ? resourceNameProp
        : defaultResourceName.current;
    const headerTitle = () => {
        const itemsCount = items.length;
        const resource = !loading &&
            ((!totalItemsCount && itemsCount === 1) || totalItemsCount === 1)
            ? resourceName.singular
            : resourceName.plural;
        if (loading) {
            return i18n.translate('Polaris.ResourceList.loading', { resource });
        }
        else if (totalItemsCount) {
            return i18n.translate('Polaris.ResourceList.showingTotalCount', {
                itemsCount,
                totalItemsCount,
                resource,
            });
        }
        else {
            return i18n.translate('Polaris.ResourceList.showing', {
                itemsCount,
                resource,
            });
        }
    };
    const bulkActionsLabel = () => {
        const selectedItemsCount = selectedItems === SELECT_ALL_ITEMS
            ? `${items.length}+`
            : selectedItems.length;
        return i18n.translate('Polaris.ResourceList.selected', {
            selectedItemsCount,
        });
    };
    const bulkActionsAccessibilityLabel = () => {
        const selectedItemsCount = selectedItems.length;
        const totalItemsCount = items.length;
        const allSelected = selectedItemsCount === totalItemsCount;
        if (totalItemsCount === 1 && allSelected) {
            return i18n.translate('Polaris.ResourceList.a11yCheckboxDeselectAllSingle', {
                resourceNameSingular: resourceName.singular,
            });
        }
        else if (totalItemsCount === 1) {
            return i18n.translate('Polaris.ResourceList.a11yCheckboxSelectAllSingle', {
                resourceNameSingular: resourceName.singular,
            });
        }
        else if (allSelected) {
            return i18n.translate('Polaris.ResourceList.a11yCheckboxDeselectAllMultiple', {
                itemsLength: items.length,
                resourceNamePlural: resourceName.plural,
            });
        }
        else {
            return i18n.translate('Polaris.ResourceList.a11yCheckboxSelectAllMultiple', {
                itemsLength: items.length,
                resourceNamePlural: resourceName.plural,
            });
        }
    };
    const paginatedSelectAllText = () => {
        if (!isSelectable || !hasMoreItems) {
            return;
        }
        if (selectedItems === SELECT_ALL_ITEMS) {
            return i18n.translate('Polaris.ResourceList.allItemsSelected', {
                itemsLength: items.length,
                resourceNamePlural: resourceName.plural,
            });
        }
    };
    const paginatedSelectAllAction = () => {
        if (!isSelectable || !hasMoreItems) {
            return;
        }
        const actionText = selectedItems === SELECT_ALL_ITEMS
            ? i18n.translate('Polaris.Common.undo')
            : i18n.translate('Polaris.ResourceList.selectAllItems', {
                itemsLength: items.length,
                resourceNamePlural: resourceName.plural,
            });
        return {
            content: actionText,
            onAction: handleSelectAllItemsInStore,
        };
    };
    const emptySearchResultText = {
        title: i18n.translate('Polaris.ResourceList.emptySearchResultTitle', {
            resourceNamePlural: resourceName.plural,
        }),
        description: i18n.translate('Polaris.ResourceList.emptySearchResultDescription'),
    };
    const handleSelectAllItemsInStore = () => {
        const newlySelectedItems = selectedItems === SELECT_ALL_ITEMS
            ? getAllItemsOnPage(items, idForItem)
            : SELECT_ALL_ITEMS;
        if (onSelectionChange) {
            onSelectionChange(newlySelectedItems);
        }
    };
    const setLoadingPosition = useCallback(() => {
        if (listRef.current != null) {
            if (typeof window === 'undefined') {
                return;
            }
            const overlay = listRef.current.getBoundingClientRect();
            const viewportHeight = Math.max(document.documentElement ? document.documentElement.clientHeight : 0, window.innerHeight || 0);
            const overflow = viewportHeight - overlay.height;
            const spinnerHeight = items.length === 1 ? SMALL_SPINNER_HEIGHT : LARGE_SPINNER_HEIGHT;
            const spinnerPosition = overflow > 0
                ? (overlay.height - spinnerHeight) / 2
                : (viewportHeight - overlay.top - spinnerHeight) / 2;
            setLoadingPositionState(spinnerPosition);
        }
    }, [listRef, items.length]);
    const itemsExist = items.length > 0;
    useEffect(() => {
        if (loading) {
            setLoadingPosition();
        }
    }, [loading, setLoadingPosition]);
    useEffect(() => {
        if (selectedItems && selectedItems.length > 0 && !selectMode) {
            setSelectMode(true);
        }
        if ((!selectedItems || selectedItems.length === 0) && !isSmallScreen()) {
            setSelectMode(false);
        }
    }, [selectedItems, selectMode]);
    useEffect(() => {
        forceUpdate();
    }, [forceUpdate, items]);
    const renderItemWithId = (item, index) => {
        const id = idForItem(item, index);
        return (<li key={id} className={styles.ItemWrapper}>
        {renderItem(item, id, index)}
      </li>);
    };
    const handleMultiSelectionChange = (lastSelected, currentSelected, resolveItemId) => {
        const min = Math.min(lastSelected, currentSelected);
        const max = Math.max(lastSelected, currentSelected);
        return items.slice(min, max + 1).map(resolveItemId);
    };
    const handleCheckableButtonRegistration = (key, button) => {
        if (!checkableButtons.get(key)) {
            setCheckableButtons(new Map(checkableButtons).set(key, button));
        }
    };
    const handleSelectionChange = (selected, id, sortOrder, shiftKey) => {
        if (selectedItems == null || onSelectionChange == null) {
            return;
        }
        let newlySelectedItems = selectedItems === SELECT_ALL_ITEMS
            ? getAllItemsOnPage(items, idForItem)
            : [...selectedItems];
        if (sortOrder !== undefined) {
            setLastSelected(sortOrder);
        }
        const lastSelectedFromState = lastSelected;
        let selectedIds = [id];
        if (shiftKey &&
            lastSelectedFromState != null &&
            sortOrder !== undefined &&
            resolveItemId) {
            selectedIds = handleMultiSelectionChange(lastSelectedFromState, sortOrder, resolveItemId);
        }
        newlySelectedItems = [...new Set([...newlySelectedItems, ...selectedIds])];
        if (!selected) {
            for (const selectedId of selectedIds) {
                newlySelectedItems.splice(newlySelectedItems.indexOf(selectedId), 1);
            }
        }
        if (newlySelectedItems.length === 0 && !isSmallScreen()) {
            handleSelectMode(false);
        }
        else if (newlySelectedItems.length > 0) {
            handleSelectMode(true);
        }
        if (onSelectionChange) {
            onSelectionChange(newlySelectedItems);
        }
    };
    const handleToggleAll = () => {
        let newlySelectedItems;
        if ((Array.isArray(selectedItems) && selectedItems.length === items.length) ||
            selectedItems === SELECT_ALL_ITEMS) {
            newlySelectedItems = [];
        }
        else {
            newlySelectedItems = items.map((item, index) => {
                return idForItem(item, index);
            });
        }
        if (newlySelectedItems.length === 0 && !isSmallScreen()) {
            handleSelectMode(false);
        }
        else if (newlySelectedItems.length > 0) {
            handleSelectMode(true);
        }
        let checkbox;
        if (isSmallScreen()) {
            checkbox = checkableButtons.get('bulkSm');
        }
        else if (newlySelectedItems.length === 0) {
            checkbox = checkableButtons.get('plain');
        }
        else {
            checkbox = checkableButtons.get('bulkLg');
        }
        if (onSelectionChange) {
            onSelectionChange(newlySelectedItems);
        }
        // setTimeout ensures execution after the Transition on BulkActions
        setTimeout(() => {
            checkbox && checkbox.focus();
        }, 0);
    };
    const bulkActionsMarkup = isSelectable ? (<div className={styles.BulkActionsWrapper}>
      <BulkActions label={bulkActionsLabel()} accessibilityLabel={bulkActionsAccessibilityLabel()} selected={bulkSelectState()} onToggleAll={handleToggleAll} selectMode={selectMode} onSelectModeToggle={handleSelectMode} promotedActions={promotedBulkActions} paginatedSelectAllAction={paginatedSelectAllAction()} paginatedSelectAllText={paginatedSelectAllText()} actions={bulkActions} disabled={loading} smallScreen={smallScreen}/>
    </div>) : null;
    const filterControlMarkup = filterControl ? (<div className={styles.FiltersWrapper}>{filterControl}</div>) : null;
    const sortingSelectMarkup = sortOptions && sortOptions.length > 0 && !alternateTool ? (<div className={styles.SortWrapper}>
        <Select label={i18n.translate('Polaris.ResourceList.sortingLabel')} labelInline={!smallScreen} labelHidden={smallScreen} options={sortOptions} onChange={onSortChange} value={sortValue} disabled={selectMode}/>
      </div>) : null;
    const alternateToolMarkup = alternateTool && !sortingSelectMarkup ? (<div className={styles.AlternateToolWrapper}>{alternateTool}</div>) : null;
    const headerTitleMarkup = (<div className={styles.HeaderTitleWrapper} testID="headerTitleWrapper">
      {headerTitle()}
    </div>);
    const selectButtonMarkup = isSelectable ? (<div className={styles.SelectButtonWrapper}>
      <Button disabled={selectMode} icon={EnableSelectionMinor} onClick={() => handleSelectMode(true)}>
        {i18n.translate('Polaris.ResourceList.selectButtonText')}
      </Button>
    </div>) : null;
    const checkableButtonMarkup = isSelectable ? (<div className={styles.CheckableButtonWrapper}>
      <CheckableButton accessibilityLabel={bulkActionsAccessibilityLabel()} label={headerTitle()} onToggleAll={handleToggleAll} plain disabled={loading}/>
    </div>) : null;
    const needsHeader = isSelectable || (sortOptions && sortOptions.length > 0) || alternateTool;
    const headerWrapperOverlay = loading ? (<div className={styles['HeaderWrapper-overlay']}/>) : null;
    const showEmptyState = emptyState && !itemsExist && !loading;
    const showEmptySearchState = !showEmptyState && filterControl && !itemsExist && !loading;
    const headerMarkup = !showEmptyState &&
        !showEmptySearchState &&
        (showHeader || needsHeader) &&
        listRef.current && (<div className={styles.HeaderOuterWrapper}>
        <Sticky boundingElement={listRef.current}>
          {(isSticky) => {
        const headerClassName = classNames(styles.HeaderWrapper, sortOptions &&
            sortOptions.length > 0 &&
            !alternateTool &&
            styles['HeaderWrapper-hasSort'], alternateTool && styles['HeaderWrapper-hasAlternateTool'], isSelectable && styles['HeaderWrapper-hasSelect'], loading && styles['HeaderWrapper-disabled'], isSelectable &&
            selectMode &&
            styles['HeaderWrapper-inSelectMode'], isSticky && styles['HeaderWrapper-isSticky']);
        return (<div className={headerClassName} testID="ResourceList-Header">
                <EventListener event="resize" handler={handleResize}/>
                {headerWrapperOverlay}
                <div className={styles.HeaderContentWrapper}>
                  {headerTitleMarkup}
                  {checkableButtonMarkup}
                  {alternateToolMarkup}
                  {sortingSelectMarkup}
                  {selectButtonMarkup}
                </div>
                {bulkActionsMarkup}
              </div>);
    }}
        </Sticky>
      </div>);
    const emptySearchStateMarkup = showEmptySearchState
        ? emptySearchState || (<div className={styles.EmptySearchResultWrapper}>
          <EmptySearchResult {...emptySearchResultText} withIllustration/>
        </div>)
        : null;
    const emptyStateMarkup = showEmptyState ? emptyState : null;
    const defaultTopPadding = 8;
    const topPadding = loadingPosition > 0 ? loadingPosition : defaultTopPadding;
    const spinnerStyle = { paddingTop: `${topPadding}px` };
    const spinnerSize = items.length < 2 ? 'small' : 'large';
    const loadingOverlay = loading ? (<React.Fragment>
      <div className={styles.SpinnerContainer} style={spinnerStyle}>
        <Spinner size={spinnerSize} accessibilityLabel="Items are loading"/>
      </div>
      <div className={styles.LoadingOverlay}/>
    </React.Fragment>) : null;
    const className = classNames(styles.ItemWrapper, loading && styles['ItemWrapper-isLoading']);
    const loadingWithoutItemsMarkup = loading && !itemsExist ? (<div className={className} tabIndex={-1}>
        {loadingOverlay}
      </div>) : null;
    const resourceListClassName = classNames(styles.ResourceList, loading && styles.disabledPointerEvents, selectMode && styles.disableTextSelection);
    const listMarkup = itemsExist ? (<ul className={resourceListClassName} ref={listRef} aria-live="polite" aria-busy={loading}>
      {loadingOverlay}
      {items.map(renderItemWithId)}
    </ul>) : null;
    const context = {
        selectable: isSelectable,
        selectedItems,
        selectMode,
        resourceName,
        loading,
        onSelectionChange: handleSelectionChange,
        registerCheckableButtons: handleCheckableButtonRegistration,
    };
    return (<ResourceListContext.Provider value={context}>
      <div className={styles.ResourceListWrapper}>
        {filterControlMarkup}
        {headerMarkup}
        {listMarkup}
        {emptySearchStateMarkup}
        {emptyStateMarkup}
        {loadingWithoutItemsMarkup}
      </div>
    </ResourceListContext.Provider>);
};
ResourceList.Item = ResourceItem;
// eslint-disable-next-line import/no-deprecated
ResourceList.FilterControl = FilterControl;
